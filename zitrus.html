<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry - lines drawcalls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="js/libs/dat.gui.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/SVGRenderer.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/Tween.js"></script>
		<script src="js/libs/THREEx.FullScreen.js"></script>

		<script>

			var group;
			var container, controls, stats, gui;
			var particlesData = [];
			var camera, scene, renderer, svgRenderer;
			var positions = [], colors = [];
			var particles = [];
			var pointCloud = [];
			var particlePositions = [];
			var geometry = [];
			var linesMesh = [];
			var tweens;
			var box;

			var maxParticleCount = 1000;
			var particleCount = 500;
			var r = 800;
			var rHalf = r / 2;

			var defaults = {
				showDots: true,
				showLines: true,
				minDistance: 60,
				minDistanceFactor: 0.999999,
				limitConnections: true,
				maxConnections: 20,
				particleCount: 500,
				onZitrusCoeff: 0.999999,
				inCubeCoeff: 0.0001,
				onSphereCoeff: 0.0001,
				atPointCoeff: 0.0001,
				inCubeCoeff2: 0.0001,
				onSphereCoeff2: 0.0001,
				atPointCoeff2: 0.999999,
				opacity: 1.0,
				opacity2: 1.0,
                delay: 3000,
                duration: 6000
			}

			var effectController = {};
			// copy over default values
			for( var attr in defaults )
				effectController[ attr ] = defaults[ attr ];
			// add additional controls
			effectController.animate = true;
			effectController.restartTweening = function() {
				TWEEN.removeAll();
				tweens[ 0 ].start();
				requestAnimationFrame( animate );
			};
			effectController.exportToSvg = function() {
				window.alert( "This feature is currently disabled. Rendering takes almost forever and the resulting SVG is wrong." );
				return;

				var generator=window.open('','name','height=400,width=500');

				generator.document.write('<html><head><title>SVG Export</title>');
				generator.document.write('</body></html>');
				generator.document.close();

				generator.document.body.appendChild( svgRenderer.domElement );
				svgRenderer.render( scene, camera );
			};
			effectController.showSettingsInPopUp = function() {
				window.alert( JSON.stringify( effectController, Object.getOwnPropertyNames( defaults ) ) );
			}
			effectController.fullscreen = function() {
				THREEx.FullScreen.request();
			}
			effectController.hideControls = function() {
				gui.domElement.style.display='none';
				stats.domElement.style.display='none';
			}
			effectController.hideBox = function() {
				box.visible = false;
			}

			function Zitrus ( theRadius, theLength, theCenter ) {
				this.radius = 4.0 * theRadius;
				this.length = theLength;
				this.center = theCenter;
			};
			Zitrus.prototype.parametric = function( phi, z ) {
				var tmp = z * ( 1.0 - z );
				tmp = Math.sqrt( tmp * tmp * tmp );
				return new THREE.Vector3( this.radius * tmp * Math.cos( phi ) - this.center.x,
					this.radius * tmp * Math.sin( phi ) - this.center.y,
					this.length * z - this.center.z );
			};
			Zitrus.prototype.implicit = function( x, y, z ) {
				x = x / r - this.center.x;
				y = y / r - this.center.y;
				z = z / length - this.center.z;
				var tmp = z * ( 1 - z );
				return x * x + y * y - tmp * tmp * tmp;
			}

			function Sphere ( theRadius, theCenter ) {
				this.radius = theRadius / 4.0;
				this.center = theCenter;
			};
			Sphere.prototype.parametric = function( phi, theta ) {
				return new THREE.Vector3( this.radius * Math.sin( theta ) * Math.cos( phi ) - this.center.x,
					this.radius * Math.sin( theta ) * Math.sin( phi ) - this.center.y,
					this.radius * Math.cos( theta ) - this.center.z );
			};

			zitrus = new Zitrus( ( Math.sqrt( 5.0 / 1.2 ) / 2.0 ) * r / 2.0, r, new THREE.Vector3( 0.0, 0.0, r / 2.0 ));
			sphere = new Sphere( r, new THREE.Vector3( 0.0, 0.0, 0.0 ) );

			function initGUI() {

				var gui = new dat.GUI( { width: 300 } );

				gui.add( effectController, "showDots" ).listen().onChange( function( value ) {
					pointCloud[ 0 ].visible = pointCloud[ 1 ].visible = value;
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "showLines" ).listen().onChange( function( value ) {
					linesMesh[ 0 ].visible = linesMesh[ 1 ].visible = value;
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "minDistance", 10, 300 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "minDistanceFactor", 0.0, 5.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "limitConnections" ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "maxConnections", 0, 30, 1 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).listen().onChange( function( value ) {
					particleCount = parseInt( value );
					particles.setDrawRange( 0, particleCount );
					requestAnimationFrame( animate );
				});
				gui.add( effectController, "onZitrusCoeff", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "inCubeCoeff", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "onSphereCoeff", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "atPointCoeff", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "onSphereCoeff2", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "opacity", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "opacity2", 0.0, 1.0 ).listen().onChange( function() {
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "animate" ).listen().onChange( function() {
					if( !effectController.animate )
						TWEEN.removeAll();
					requestAnimationFrame( animate );
				} );
				gui.add( effectController, "restartTweening" );
				gui.add( effectController, "showSettingsInPopUp" );
				gui.add( effectController, "exportToSvg" );
				gui.add( effectController, "fullscreen" );
				gui.add( effectController, "hideControls" );
				gui.add( effectController, "hideBox" );

				return gui;
			}

			function newParticleData() {
				return {
					on_zitrus: {
						phi: 2.0 * Math.PI * Math.random(),
						z: Math.random(),
						pos: zitrus.parametric( this.phi, this.z ),
						velocity_phi: 2 * Math.PI * ( Math.random() * 2 - 1 ) / 500,
						velocity_z: ( Math.random() * 2 - 1 ) / 500
					},
					in_cube: {
						pos: new THREE.Vector3( Math.random() * r - r / 2, Math.random() * r - r / 2, Math.random() * r - r / 2 ),
						velocity:
						//new THREE.Vector3( 0.0, 0.0, 0.0 ),
						new THREE.Vector3( -1 + Math.random() * 2, -1 + Math.random() * 2,  -1 + Math.random() * 2 )
					},
					on_sphere: {
						phi: 2.0 * Math.PI * Math.random(),
						theta: 2.0 * Math.PI * Math.random(),
						pos: sphere.parametric( this.phi, this.theta ),
						velocity_phi: 2 * Math.PI * ( Math.random() * 2 - 1 ) / 500,
						velocity_theta: 2 * Math.PI * ( Math.random() * 2 - 1 ) / 500
					},
					at_point: {
						pos: new THREE.Vector3( 0, 0, 0 )
					},
					numConnections: [0,0]
				};
			}

			function init() {

				gui = initGUI();

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1750;

				controls = new THREE.OrbitControls( camera, container );

				scene = new THREE.Scene();


				group = new THREE.Group();
				scene.add( group );

				var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
				helper.material.color.setHex( 0x080808 );
				helper.material.blending = THREE.AdditiveBlending;
				helper.material.transparent = true;
				group.add( helper );
				box = helper;

				var segments = maxParticleCount * maxParticleCount;

				for ( var i = 0; i < maxParticleCount; i++ ) {
					// create new particle data
					var data = newParticleData();

					// fix at least two points at the singularities
					if( i == 0 || i == 1 )
					{
						data.on_zitrus.z = i == 0 ? 0.0 : 1.0;
						data.on_zitrus.velocity_z = 0.0;
						data.on_zitrus.pos = zitrus.parametric( data.on_zitrus.phi, data.on_zitrus.z );
					}

					// add it to the geometry
					particlesData.push( data );
				}

				for( g = 0; g < 2; ++g )
				{
					var pMaterial = new THREE.PointsMaterial( {
						color: 0xFFFFFF,
						size: 5,
						blending: THREE.AdditiveBlending,
						transparent: true,
						sizeAttenuation: false,
						opacity: 1.0
					} );

					var material = new THREE.LineBasicMaterial( {
						vertexColors: THREE.VertexColors,
						blending: THREE.AdditiveBlending,
						transparent: true,
						opacity: 1.0,
                        linewidth: 2
					} );

					positions[ g ] = new Float32Array( segments * 3 );
					colors[ g ] = new Float32Array( segments * 3 );

					particles[ g ] = new THREE.BufferGeometry();
					particlePositions[ g ] = new Float32Array( maxParticleCount * 3 );

					particles[ g ].setDrawRange( 0, particleCount );
					particles[ g ].addAttribute( 'position', new THREE.BufferAttribute( particlePositions[ g ], 3 ).setDynamic( true ) );

					// create the particle system
					pointCloud[ g ] = new THREE.Points( particles[ g ], pMaterial );
					group.add( pointCloud[ g ] );

					geometry[ g ] = new THREE.BufferGeometry();

					geometry[ g ].addAttribute( 'position', new THREE.BufferAttribute( positions[ g ], 3 ).setDynamic( true ) );
					geometry[ g ].addAttribute( 'color', new THREE.BufferAttribute( colors[ g ], 3 ).setDynamic( true ) );

					//geometry.computeBoundingSphere();

					geometry[ g ].setDrawRange( 0, 0 );

					linesMesh[ g ] = new THREE.LineSegments( geometry[ g ], material );
					group.add( linesMesh[ g ] );
				}

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 1.0 );
				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				svgRenderer = new THREE.SVGRenderer();
				svgRenderer.setClearColor( 0x000000 );
				svgRenderer.setSize( window.innerWidth, window.innerHeight );
				svgRenderer.setQuality( 'high' );

				container.appendChild( renderer.domElement );
				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				// initialize tweens and put them in order into an array
				tweens = [];
/*
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( defaults, 2000 )
					.delay( 1000 ) );
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { interpolation: 0.0 }, 2000 )
					.delay( 1000 ) );
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Bounce.InOut )
					.to( { maxConnections: 1 }, 2000 )
					.delay( 1000 ) );
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Bounce.InOut )
					.to( { maxConnections: defaults.maxConnections }, 2000 ) );
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( {"showDots":true,"showLines":true,"minDistance":17.62937044539739,"limitConnections":true,"maxConnections":30,"particleCount":1000,"interpolation":0}, 2000 ) );
*/

				// point
				tweens.push( new TWEEN.Tween( effectController )
					.to( defaults, 0 )
					.to( { onZitrusCoeff: 0.0, inCubeCoeff: 0.0, onSphereCoeff: 0.0, atPointCoeff: 1.0, inCubeCoeff2: 0.0, onSphereCoeff2: 0.0, atPointCoeff2: 1.0, minDistanceFactor: 0.0, opacity: 0.0, opacity2: 0.0 }, 0 ) );
				// cube
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { atPointCoeff: 0.0, inCubeCoeff: 1.0, minDistanceFactor: 2.0, opacity: 1.0 }, effectController.duration )
					.delay( 0 ) );
				// zitrus
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { inCubeCoeff: 0.0, onZitrusCoeff: 1.0, minDistanceFactor: 1.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// cube
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { onZitrusCoeff: 0.0, inCubeCoeff: 1.0, minDistanceFactor: 2.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// sphere
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { inCubeCoeff: 0.0, onSphereCoeff: 1.0, minDistanceFactor: 1.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// cube
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { onSphereCoeff: 0.0, inCubeCoeff: 1.0, minDistanceFactor: 2.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// zitrus and sphere
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { inCubeCoeff: 0.0, onZitrusCoeff: 1.0, minDistanceFactor: 1.0, inCubeCoeff2: 0.0, onSphereCoeff2: 1.0, atPointCoeff2: 0.0, opacity2: 1.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// cube
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( { onZitrusCoeff: 0.0, inCubeCoeff: 1.0, inCubeCoeff2: 1.0, onSphereCoeff2: 0.0, minDistanceFactor: 2.0, opacity2: 0.0 }, effectController.duration )
					.delay( effectController.delay ) );
				// point
				tweens.push( new TWEEN.Tween( effectController )
					.easing( TWEEN.Easing.Cubic.InOut )
					.to( defaults, effectController.duration )
					.to( { inCubeCoeff: 0.0, atPointCoeff: 1.0, inCubeCoeff2: 0.0, atPointCoeff2: 1.0, minDistanceFactor: 0.0, opacity: 0.0, opacity2: 0.0 }, effectController.duration )
					.delay( effectController.delay ) );
				tweens.push( new TWEEN.Tween( effectController )
					.delay( effectController.delay / 2.0 )
					.onComplete( function() { startTimeMs = Date.now(); } ) );

				// actually chain tweens and start them
				for( var i = 0; i < tweens.length - 1; i++ )
					tweens[ i ].chain( tweens[ i + 1 ] );
				tweens[ tweens.length - 1 ].chain( tweens[ 0 ] );
				tweens[ 0 ].start();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				TWEEN.update();

				for ( var i = 0; i < particleCount; i++ ) {
					// get the particle
					var particleData = particlesData[i];
					var on_zitrus = particleData.on_zitrus;
					var in_cube = particleData.in_cube;
					var on_sphere = particleData.on_sphere;
					var at_point = particleData.at_point;

					// reset number of connections for this frame
					particleData.numConnections = [ 0, 0 ];

					if( effectController.animate ) {
						// update particle positions and velocities of the on_zitrus part
						on_zitrus.pos = zitrus.parametric( on_zitrus.phi, on_zitrus.z );
						on_zitrus.z += on_zitrus.velocity_z;
						on_zitrus.phi += on_zitrus.velocity_phi;
						if( on_zitrus.phi > 2.0 * Math.PI )
							on_zitrus.phi -= 2.0 * Math.PI;
						else if( on_zitrus.phi < 0.0 )
							on_zitrus.phi += 2.0 * Math.PI;
						if( on_zitrus.z > 1.0 )
							on_zitrus.z -= 1.0;
						else if( on_zitrus.z < 0.0 )
							on_zitrus.z += 1.0

						// update particle positions and velocities of the in_cube part
						in_cube.pos.add( in_cube.velocity );

						if ( in_cube.pos.x < -rHalf || in_cube.pos.x > rHalf )
							in_cube.velocity.x = -in_cube.velocity.x;

						if ( in_cube.pos.y < -rHalf || in_cube.pos.y > rHalf )
							in_cube.velocity.y = -in_cube.velocity.y;

						if ( in_cube.pos.z < -rHalf || in_cube.pos.z > rHalf )
							in_cube.velocity.z = -in_cube.velocity.z;

						// update particle positions and velocities of the on_sphere part
						on_sphere.pos = sphere.parametric( on_sphere.phi, on_sphere.theta );
						on_sphere.phi += on_sphere.velocity_phi;
						on_sphere.theta += on_sphere.velocity_theta;
					}

					// update vertex buffer
					var in_between = new THREE.Vector3()
						.addScaledVector( on_zitrus.pos, effectController.onZitrusCoeff )
						.addScaledVector( in_cube.pos, effectController.inCubeCoeff )
						.addScaledVector( on_sphere.pos, effectController.onSphereCoeff )
						.addScaledVector( at_point.pos, effectController.atPointCoeff );
					particlePositions[ 0 ][ i * 3	 ] = in_between.x;
					particlePositions[ 0 ][ i * 3 + 1 ] = in_between.y;
					particlePositions[ 0 ][ i * 3 + 2 ] = in_between.z;

					// update vertex buffer
					var in_between2 = new THREE.Vector3()
						.addScaledVector( in_cube.pos, effectController.inCubeCoeff2 )
						.addScaledVector( on_sphere.pos, effectController.onSphereCoeff2 )
						.addScaledVector( at_point.pos, effectController.atPointCoeff2 );
					particlePositions[ 1 ][ i * 3	 ] = in_between2.x;
					particlePositions[ 1 ][ i * 3 + 1 ] = in_between2.y;
					particlePositions[ 1 ][ i * 3 + 2 ] = in_between2.z;
				}

				for( g = 0; g < 2; ++g )
				{
					var vertexpos = 0;
					var colorpos = 0;
					var numConnected = 0;

					for ( var i = 0; i < particleCount; i++ ) {
						var particleDataA = particlesData[ i ];

						if ( effectController.limitConnections && particleDataA.numConnections[ g ] >= effectController.maxConnections )
							continue;

						// Check collision
						for ( var j = i + 1; j < particleCount; j++ ) {
							var particleDataB = particlesData[ j ];
							if ( effectController.limitConnections && particleDataB.numConnections[ g ] >= effectController.maxConnections )
								continue;

							var dx = particlePositions[ g ][ i * 3	 ] - particlePositions[ g ][ j * 3	 ];
							var dy = particlePositions[ g ][ i * 3 + 1 ] - particlePositions[ g ][ j * 3 + 1 ];
							var dz = particlePositions[ g ][ i * 3 + 2 ] - particlePositions[ g ][ j * 3 + 2 ];
							var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );

							var minDistance = effectController.minDistance * effectController.minDistanceFactor;
							if ( dist < minDistance ) {

								particleDataA.numConnections[ g ]++;
								particleDataB.numConnections[ g ]++;

								var alpha = 1.0 - dist / minDistance;

								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ i * 3	 ];
								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ i * 3 + 1 ];
								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ i * 3 + 2 ];

								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ j * 3	 ];
								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ j * 3 + 1 ];
								positions[ g ][ vertexpos++ ] = particlePositions[ g ][ j * 3 + 2 ];

								colors[ g ][ colorpos++ ] = alpha;
								colors[ g ][ colorpos++ ] = alpha;
								colors[ g ][ colorpos++ ] = alpha;

								colors[ g ][ colorpos++ ] = alpha;
								colors[ g ][ colorpos++ ] = alpha;
								colors[ g ][ colorpos++ ] = alpha;

								numConnected++;
							}
						}
					}

					linesMesh[ g ].geometry.setDrawRange( 0, numConnected * 2 );
					linesMesh[ g ].geometry.attributes.position.needsUpdate = true;
					linesMesh[ g ].geometry.attributes.color.needsUpdate = true;

					pointCloud[ g ].geometry.attributes.position.needsUpdate = true;

					linesMesh[ g ].visible = !( ( g == 0 && effectController.atPointCoeff == 1.0 ) || ( g == 1 && effectController.atPointCoeff2 == 1.0 ) );
					pointCloud[ g ].visible = !( ( g == 0 && effectController.atPointCoeff == 1.0 ) || ( g == 1 && effectController.atPointCoeff2 == 1.0 ) );

					linesMesh[ g ].material.opacity = g == 0 ? effectController.opacity : effectController.opacity2;
					linesMesh[ g ].material.needsUpdate = true;

					pointCloud[ g ].material.opacity = g == 0 ? effectController.opacity : effectController.opacity2;
					pointCloud[ g ].material.needsUpdate = true;
				}

				if( effectController.animate )
					requestAnimationFrame( animate );

				stats.update();
				render();
			}

			var startTimeMs = Date.now();
			var firstRotationKeyFrameAfterS = 3 + 6 + 3 + 3;
			var secondRotationKeyFrameAfterAdditionalS = 3 + 3 + 6 + 3 + 6 + 3 + 6 + 3 + 3;
			var rotationsOffsetMs = firstRotationKeyFrameAfterS * 1000.0;
			var rotationsPerSecond = 1.0 / secondRotationKeyFrameAfterAdditionalS;
			// for debugging
            //window.setTimeout( function(){alert();},rotationsOffsetMs + (3 + 3 + 6 + 3 + 6 + 3 + 6 + 3 + 3)*1000.0);
			function render() {
				group.rotation.y = ( ( rotationsPerSecond * ( Date.now() - startTimeMs - rotationsOffsetMs ) / 1000.0 ) + 0.25 ) * 2.0 * Math.PI;
				renderer.render( scene, camera );
			}

			init();
			animate();
		</script>
	</body>
</html>
